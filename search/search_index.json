{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"FAONet","text":"<p>Welcome to the documentation for FAONet, a Python package for analyzing bipartite trade networks using FAOSTAT data.</p> <p>Use the sidebar to navigate through the API reference and examples.</p>"},{"location":"reference/","title":"API Reference","text":""},{"location":"reference/#io-functions","title":"I/O Functions","text":""},{"location":"reference/#faonet.io.load_and_merge_csv","title":"<code>load_and_merge_csv(filepaths)</code>","text":"<p>Load and concatenate multiple FAOSTAT CSV files into a single DataFrame.</p>"},{"location":"reference/#faonet.io.load_and_merge_csv--parameters","title":"Parameters","text":"<p>filepaths : list of str     List of paths to the CSV files.</p>"},{"location":"reference/#faonet.io.load_and_merge_csv--returns","title":"Returns","text":"<p>pd.DataFrame     A single DataFrame resulting from concatenation of all input files.</p> Source code in <code>faonet/io.py</code> <pre><code>def load_and_merge_csv(filepaths):\n    \"\"\"\n    Load and concatenate multiple FAOSTAT CSV files into a single DataFrame.\n\n    Parameters\n    ----------\n    filepaths : list of str\n        List of paths to the CSV files.\n\n    Returns\n    -------\n    pd.DataFrame\n        A single DataFrame resulting from concatenation of all input files.\n    \"\"\"\n\n    dataframes = [pd.read_csv(path) for path in filepaths]\n    return pd.concat(dataframes, ignore_index=True)\n</code></pre>"},{"location":"reference/#faonet.io.load_file","title":"<code>load_file(file, year=2023)</code>","text":"<p>Load a single FAOSTAT CSV file and filter by a specific year.</p>"},{"location":"reference/#faonet.io.load_file--parameters","title":"Parameters","text":"<p>file : str or path-like     Path to the CSV file. year : int, optional     Year to filter the data by (default is 2023).</p>"},{"location":"reference/#faonet.io.load_file--returns","title":"Returns","text":"<p>pd.DataFrame     DataFrame filtered to only include data from the specified year.</p> Source code in <code>faonet/io.py</code> <pre><code>def load_file(file, year=2023):\n    \"\"\"\n    Load a single FAOSTAT CSV file and filter by a specific year.\n\n    Parameters\n    ----------\n    file : str or path-like\n        Path to the CSV file.\n    year : int, optional\n        Year to filter the data by (default is 2023).\n\n    Returns\n    -------\n    pd.DataFrame\n        DataFrame filtered to only include data from the specified year.\n    \"\"\"\n\n    dataframes = pd.read_csv(file)\n    return dataframes[dataframes['Year'] == year]\n</code></pre>"},{"location":"reference/#faonet.io.save_dataframe","title":"<code>save_dataframe(df, filepath)</code>","text":"<p>Save a pandas DataFrame to a CSV file.</p>"},{"location":"reference/#faonet.io.save_dataframe--parameters","title":"Parameters","text":"<p>df : pd.DataFrame     The DataFrame to save. filepath : str     Destination path for the output CSV file.</p> Source code in <code>faonet/io.py</code> <pre><code>def save_dataframe(df, filepath):\n    \"\"\"\n    Save a pandas DataFrame to a CSV file.\n\n    Parameters\n    ----------\n    df : pd.DataFrame\n        The DataFrame to save.\n    filepath : str\n        Destination path for the output CSV file.\n    \"\"\"\n    df.to_csv(filepath, index=False)\n</code></pre>"},{"location":"reference/#metrics","title":"Metrics","text":""},{"location":"reference/#faonet.metrics.compute_betweenness_all","title":"<code>compute_betweenness_all(G)</code>","text":"<p>Compute multiple betweenness centrality measures for a bipartite network.</p> <p>This function calculates: - Betweenness in the full bipartite network using both real and inverted weights. - Betweenness in the projected graphs (for exporters and importers), again with real and inverted weights.</p>"},{"location":"reference/#faonet.metrics.compute_betweenness_all--parameters","title":"Parameters","text":"<p>G : networkx.Graph     Bipartite graph with edge attribute 'weight'.</p>"},{"location":"reference/#faonet.metrics.compute_betweenness_all--returns","title":"Returns","text":"<p>pd.DataFrame     DataFrame with one row per node and the following columns:     - 'node': Node identifier     - 'bipartite_set': 0 if exporter, 1 if importer     - 'betweenness_bipartite': Centrality in full bipartite graph (weights)     - 'betweenness_bipartite_inv': Centrality in full bipartite graph (inverted weights)     - 'betweenness_proj_exporters': Centrality in exporter projection (weights)     - 'betweenness_proj_exporters_inv': Centrality in exporter projection (inverted weights)     - 'betweenness_proj_importers': Centrality in importer projection (weights)     - 'betweenness_proj_importers_inv': Centrality in importer projection (inverted weights)</p> Source code in <code>faonet/metrics.py</code> <pre><code>def compute_betweenness_all(G):\n    \"\"\"\n    Compute multiple betweenness centrality measures for a bipartite network.\n\n    This function calculates:\n    - Betweenness in the full bipartite network using both real and inverted weights.\n    - Betweenness in the projected graphs (for exporters and importers), again with real and inverted weights.\n\n    Parameters\n    ----------\n    G : networkx.Graph\n        Bipartite graph with edge attribute 'weight'.\n\n    Returns\n    -------\n    pd.DataFrame\n        DataFrame with one row per node and the following columns:\n        - 'node': Node identifier\n        - 'bipartite_set': 0 if exporter, 1 if importer\n        - 'betweenness_bipartite': Centrality in full bipartite graph (weights)\n        - 'betweenness_bipartite_inv': Centrality in full bipartite graph (inverted weights)\n        - 'betweenness_proj_exporters': Centrality in exporter projection (weights)\n        - 'betweenness_proj_exporters_inv': Centrality in exporter projection (inverted weights)\n        - 'betweenness_proj_importers': Centrality in importer projection (weights)\n        - 'betweenness_proj_importers_inv': Centrality in importer projection (inverted weights)\n    \"\"\"\n    # Identify bipartite sets\n    exportadores = {n for n, d in G.nodes(data=True) if d.get(\"bipartite\") == 0}\n    importadores = set(G) - exportadores\n\n    # Invert weights for shortest-path based betweenness\n    G_inv = G.copy()\n    for u, v, d in G_inv.edges(data=True):\n        peso = d.get(\"weight\", 1)\n        d[\"inv_weight\"] = 1 / peso if peso &gt; 0 else 0\n\n    # Betweenness in original bipartite network\n    bet_bip = nx.betweenness_centrality(G, weight=\"weight\")\n    bet_bip_inv = nx.betweenness_centrality(G_inv, weight=\"inv_weight\")\n\n    # Projected graphs\n    proy_exp = bipartite.weighted_projected_graph(G, exportadores)\n    proy_imp = bipartite.weighted_projected_graph(G, importadores)\n\n    # Betweenness in projections (real weights)\n    bet_proy_exp = nx.betweenness_centrality(proy_exp, weight=\"weight\")\n    bet_proy_imp = nx.betweenness_centrality(proy_imp, weight=\"weight\")\n\n    # Invert weights in projections\n    for _, _, d in proy_exp.edges(data=True):\n        d[\"inv_weight\"] = 1 / d[\"weight\"] if d[\"weight\"] &gt; 0 else 0\n    for _, _, d in proy_imp.edges(data=True):\n        d[\"inv_weight\"] = 1 / d[\"weight\"] if d[\"weight\"] &gt; 0 else 0\n\n    bet_proy_exp_inv = nx.betweenness_centrality(proy_exp, weight=\"inv_weight\")\n    bet_proy_imp_inv = nx.betweenness_centrality(proy_imp, weight=\"inv_weight\")\n\n    # Build results\n    nodos = list(G.nodes())\n    df_bet = pd.DataFrame({\n        \"node\": nodos,\n        \"bipartite_set\": [G.nodes[n].get(\"bipartite\") for n in nodos],\n        \"betweenness_bipartite\": [bet_bip.get(n, 0) for n in nodos],\n        \"betweenness_bipartite_inv\": [bet_bip_inv.get(n, 0) for n in nodos],\n        \"betweenness_proj_exporters\": [bet_proy_exp.get(n, None) for n in nodos],\n        \"betweenness_proj_exporters_inv\": [bet_proy_exp_inv.get(n, None) for n in nodos],\n        \"betweenness_proj_importers\": [bet_proy_imp.get(n, None) for n in nodos],\n        \"betweenness_proj_importers_inv\": [bet_proy_imp_inv.get(n, None) for n in nodos],\n    })\n\n    return df_bet\n</code></pre>"},{"location":"reference/#faonet.metrics.compute_bipartite_clustering","title":"<code>compute_bipartite_clustering(G, reporters=None, normalized=True)</code>","text":"<p>Compute bipartite clustering coefficients C4b and C4b^w for each node in a bipartite graph.</p>"},{"location":"reference/#faonet.metrics.compute_bipartite_clustering--parameters","title":"Parameters","text":"<p>G : networkx.Graph     Bipartite graph with edge attribute 'weight'.     reporters (set, optional): Set of nodes considered \"Exportadores\".                                 All others will be labeled \"Importadores\" if this is provided.     normalized (bool): Whether to use normalized version of the clustering.</p>"},{"location":"reference/#faonet.metrics.compute_bipartite_clustering--returns","title":"Returns","text":"<p>pd.DataFrame:      DataFrame with C4b, C4b^w, their ratio, degree and type.</p> Source code in <code>faonet/metrics.py</code> <pre><code>def compute_bipartite_clustering(G, reporters=None, normalized=True):\n    \"\"\"\n    Compute bipartite clustering coefficients C4b and C4b^w for each node in a bipartite graph.\n\n    Parameters\n    ----------\n    G : networkx.Graph\n        Bipartite graph with edge attribute 'weight'.\n        reporters (set, optional): Set of nodes considered \"Exportadores\". \n                                   All others will be labeled \"Importadores\" if this is provided.\n        normalized (bool): Whether to use normalized version of the clustering.\n\n    Returns\n    -------\n    pd.DataFrame: \n        DataFrame with C4b, C4b^w, their ratio, degree and type.\n    \"\"\"\n\n    def c4b_node(G, node):\n        neighbors = list(G[node])\n        k_i = len(neighbors)\n        s_i = sum(G[node][n].get(\"weight\", 1) for n in neighbors)\n\n        if k_i &lt; 2:\n            return 0.0, 0.0\n\n        neighbor_pairs = list(itertools.combinations(neighbors, 2))\n        q_i = 0\n        qw_i = 0.0\n\n        for m, n in neighbor_pairs:\n            neighbors_m = set(G[m])\n            neighbors_n = set(G[n])\n            common = neighbors_m &amp; neighbors_n - {node}\n\n            for v in common:\n                q_i += 1\n                w_im = G[node][m].get(\"weight\", 1)\n                w_in = G[node][n].get(\"weight\", 1)\n                wnorm_m = w_im / s_i if s_i &gt; 0 else 0\n                wnorm_n = w_in / s_i if s_i &gt; 0 else 0\n                qw_i += (wnorm_m + wnorm_n) / 2\n\n        # Normalization term\n        k_nn = len(set.union(*(set(G[n]) for n in neighbors)) - {node})\n        Q_i = k_i * (k_i - 1) / 2 * k_nn if normalized else 1\n\n        C4b = q_i / Q_i if Q_i &gt; 0 else 0\n        C4bw = qw_i / Q_i if Q_i &gt; 0 else 0\n        return C4b, C4bw\n\n    # Compute clustering for all nodes\n    results = []\n    for node in G.nodes():\n        c4b, c4bw = c4b_node(G, node)\n        results.append({\n            \"node\": node,\n            \"C4b\": c4b,\n            \"C4b^w\": c4bw,\n            \"degree\": G.degree(node)\n        })\n\n    df = pd.DataFrame(results)\n    df[\"C4_rate\"] = df[\"C4b^w\"] / df[\"C4b\"]\n    df.replace([np.inf, -np.inf], np.nan, inplace=True)\n\n    if reporters is not None:\n        df[\"tipo\"] = df[\"node\"].apply(lambda x: \"Exportador\" if x in reporters else \"Importador\")\n\n    return df\n</code></pre>"},{"location":"reference/#faonet.metrics.compute_degree_and_strength","title":"<code>compute_degree_and_strength(B, reporters, partners)</code>","text":"<p>Compute the degree and strength (sum of edge weights) for nodes in a bipartite network.</p>"},{"location":"reference/#faonet.metrics.compute_degree_and_strength--parameters","title":"Parameters","text":"<p>B : networkx.Graph     Bipartite graph with weights on the edges (under the 'weight' attribute). reporters : set     Set of nodes in one bipartite group (e.g., exporters). partners : set     Set of nodes in the other bipartite group (e.g., importers).</p>"},{"location":"reference/#faonet.metrics.compute_degree_and_strength--returns","title":"Returns","text":"<p>tuple of pd.DataFrame     (df_exporters, df_importers):     - df_exporters : DataFrame with 'Degree' and 'Strength' for reporter nodes.     - df_importers : DataFrame with 'Degree' and 'Strength' for partner nodes.</p> <p>Compute degree and strength (sum of weights) for nodes in a bipartite network.</p> Source code in <code>faonet/metrics.py</code> <pre><code>def compute_degree_and_strength(B, reporters, partners):\n    \"\"\"\n    Compute the degree and strength (sum of edge weights) for nodes in a bipartite network.\n\n    Parameters\n    ----------\n    B : networkx.Graph\n        Bipartite graph with weights on the edges (under the 'weight' attribute).\n    reporters : set\n        Set of nodes in one bipartite group (e.g., exporters).\n    partners : set\n        Set of nodes in the other bipartite group (e.g., importers).\n\n    Returns\n    -------\n    tuple of pd.DataFrame\n        (df_exporters, df_importers):\n        - df_exporters : DataFrame with 'Degree' and 'Strength' for reporter nodes.\n        - df_importers : DataFrame with 'Degree' and 'Strength' for partner nodes.\n\n    Compute degree and strength (sum of weights) for nodes in a bipartite network.\n    \"\"\"\n    # Compute strength: sum of edge weights per node\n    strength = {\n        node: sum(data['weight'] for _, _, data in B.edges(node, data=True))\n        for node in B.nodes()\n    }\n\n    # Compute degree using built-in function\n    degree = dict(B.degree())\n\n    # Separate by node group\n    exporters_strength = {node: strength[node] for node in reporters}\n    importers_strength = {node: strength[node] for node in partners}\n    exporters_degree = {node: degree[node] for node in reporters}\n    importers_degree = {node: degree[node] for node in partners}\n\n    # Create dataframes\n    df_exporters = pd.DataFrame({\n        \"Degree\": pd.Series(exporters_degree),\n        \"Strength\": pd.Series(exporters_strength)\n    }).dropna()\n\n    df_importers = pd.DataFrame({\n        \"Degree\": pd.Series(importers_degree),\n        \"Strength\": pd.Series(importers_strength)\n    }).dropna()\n\n    return df_exporters, df_importers\n</code></pre>"},{"location":"reference/#faonet.metrics.degree_by_group","title":"<code>degree_by_group(G, group_nodes)</code>","text":"<p>Compute the degree (number of connections) for a given group of nodes.</p>"},{"location":"reference/#faonet.metrics.degree_by_group--parameters","title":"Parameters","text":"<p>G : networkx.Graph     The network graph. group_nodes : iterable     Set or list of nodes for which to compute the degree.</p>"},{"location":"reference/#faonet.metrics.degree_by_group--returns","title":"Returns","text":"<p>pd.DataFrame     DataFrame with columns ['Node', 'Degree'].</p> Source code in <code>faonet/metrics.py</code> <pre><code>def degree_by_group(G, group_nodes):\n    \"\"\"\n    Compute the degree (number of connections) for a given group of nodes.\n\n    Parameters\n    ----------\n    G : networkx.Graph\n        The network graph.\n    group_nodes : iterable\n        Set or list of nodes for which to compute the degree.\n\n    Returns\n    -------\n    pd.DataFrame\n        DataFrame with columns ['Node', 'Degree'].\n    \"\"\"\n    degrees = {n: G.degree(n) for n in group_nodes}\n    return pd.DataFrame(degrees.items(), columns=[\"Node\", \"Degree\"])\n</code></pre>"},{"location":"reference/#network-builder","title":"Network Builder","text":""},{"location":"reference/#faonet.network.build_bipartite_network","title":"<code>build_bipartite_network(df, reporter_col, partner_col, weight_col)</code>","text":"<p>Construct a bipartite network from a FAOSTAT-style trade DataFrame.</p>"},{"location":"reference/#faonet.network.build_bipartite_network--parameters","title":"Parameters","text":"<p>df : pd.DataFrame     The input data containing trade flows. reporter_col : str     Column name for exporter (reporter) countries. partner_col : str     Column name for importer (partner) countries. weight_col : str     Column name for trade volume or weight of the connection.</p>"},{"location":"reference/#faonet.network.build_bipartite_network--returns","title":"Returns","text":"<p>B : networkx.Graph     A bipartite NetworkX graph with edge weights. reporters : set     Set of nodes representing exporters (bipartite=0). partners : set     Set of nodes representing importers (bipartite=1).</p> Source code in <code>faonet/network.py</code> <pre><code>def build_bipartite_network(df, reporter_col, partner_col, weight_col):\n    \"\"\"\n    Construct a bipartite network from a FAOSTAT-style trade DataFrame.\n\n    Parameters\n    ----------\n    df : pd.DataFrame\n        The input data containing trade flows.\n    reporter_col : str\n        Column name for exporter (reporter) countries.\n    partner_col : str\n        Column name for importer (partner) countries.\n    weight_col : str\n        Column name for trade volume or weight of the connection.\n\n    Returns\n    -------\n    B : networkx.Graph\n        A bipartite NetworkX graph with edge weights.\n    reporters : set\n        Set of nodes representing exporters (bipartite=0).\n    partners : set\n        Set of nodes representing importers (bipartite=1).\n    \"\"\"\n    B = nx.Graph()\n    reporters = set(df[reporter_col])\n    partners = set(df[partner_col])\n\n    B.add_nodes_from(reporters, bipartite=0)\n    B.add_nodes_from(partners, bipartite=1)\n\n    for _, row in df.iterrows():\n        B.add_edge(row[reporter_col], row[partner_col], weight=row[weight_col])\n\n    return B, reporters, partners\n</code></pre>"},{"location":"reference/#faonet.network.remove_zero_weight_edges","title":"<code>remove_zero_weight_edges(G)</code>","text":"<p>Remove all edges with zero weight from a NetworkX graph.</p>"},{"location":"reference/#faonet.network.remove_zero_weight_edges--parameters","title":"Parameters","text":"<p>G : networkx.Graph     The input graph, which must contain a 'weight' attribute on edges.</p>"},{"location":"reference/#faonet.network.remove_zero_weight_edges--returns","title":"Returns","text":"<p>G : networkx.Graph     The modified graph with zero-weight edges removed.</p> Source code in <code>faonet/network.py</code> <pre><code>def remove_zero_weight_edges(G):\n    \"\"\"\n    Remove all edges with zero weight from a NetworkX graph.\n\n    Parameters\n    ----------\n    G : networkx.Graph\n        The input graph, which must contain a 'weight' attribute on edges.\n\n    Returns\n    -------\n    G : networkx.Graph\n        The modified graph with zero-weight edges removed.\n    \"\"\"\n    zero_edges = [(u, v) for u, v, d in G.edges(data=True) if d.get(\"weight\", 1) == 0]\n    G.remove_edges_from(zero_edges)\n    return G\n</code></pre>"},{"location":"reference/#filtering","title":"Filtering","text":""},{"location":"reference/#faonet.filtering.filter_top_percentile","title":"<code>filter_top_percentile(df, value_column='Value', percentile=0.9)</code>","text":"<p>Filter a DataFrame to retain rows that account for a given cumulative percentile of a value column.</p>"},{"location":"reference/#faonet.filtering.filter_top_percentile--parameters","title":"Parameters","text":"<p>df : pd.DataFrame     Input DataFrame to be filtered. value_column : str     Column name to use for cumulative sum and filtering (e.g., trade value). percentile : float     Cumulative threshold to retain (between 0 and 1, e.g., 0.9 for top 90%).</p>"},{"location":"reference/#faonet.filtering.filter_top_percentile--returns","title":"Returns","text":"<p>pd.DataFrame     Filtered DataFrame containing only the rows that fall within the specified cumulative percentile.</p> Source code in <code>faonet/filtering.py</code> <pre><code>def filter_top_percentile(df, value_column=\"Value\", percentile=0.9):\n    \"\"\"\n    Filter a DataFrame to retain rows that account for a given cumulative percentile of a value column.\n\n    Parameters\n    ----------\n    df : pd.DataFrame\n        Input DataFrame to be filtered.\n    value_column : str\n        Column name to use for cumulative sum and filtering (e.g., trade value).\n    percentile : float\n        Cumulative threshold to retain (between 0 and 1, e.g., 0.9 for top 90%).\n\n    Returns\n    -------\n    pd.DataFrame\n        Filtered DataFrame containing only the rows that fall within the specified cumulative percentile.\n\n    \"\"\"\n    df_sorted = df.sort_values(by=value_column, ascending=False)\n    total_value = df_sorted[value_column].sum()\n    df_sorted[\"cumsum\"] = df_sorted[value_column].cumsum()\n    df_sorted[\"cumperc\"] = df_sorted[\"cumsum\"] / total_value\n    return df_sorted[df_sorted[\"cumperc\"] &lt;= percentile].copy()\n</code></pre>"},{"location":"reference/#plotting","title":"Plotting","text":""},{"location":"reference/#faonet.plots.plot_bipartite_network2","title":"<code>plot_bipartite_network2(B, group0_nodes, title=None, figsize=(12, 8), node_size=700, font_size=10)</code>","text":"<p>Plot a bipartite network using NetworkX with edge weights shown as color intensity.</p>"},{"location":"reference/#faonet.plots.plot_bipartite_network2--parameters","title":"Parameters","text":"<p>B : networkx.Graph     Bipartite graph with 'weight' attributes on edges. group0_nodes : list or set     Nodes from one bipartite group (used for layout positioning). title : str, optional     Title of the plot. figsize : tuple     Figure size in inches. node_size : int     Size of the nodes in the plot. font_size : int     Font size for node labels.</p>"},{"location":"reference/#faonet.plots.plot_bipartite_network2--returns","title":"Returns","text":"<p>matplotlib.axes.Axes     The matplotlib Axes object of the plot.</p> Source code in <code>faonet/plots.py</code> <pre><code>def plot_bipartite_network2(B, group0_nodes, title=None, figsize=(12, 8), node_size=700, font_size=10):\n    \"\"\"\n    Plot a bipartite network using NetworkX with edge weights shown as color intensity.\n\n    Parameters\n    ----------\n    B : networkx.Graph\n        Bipartite graph with 'weight' attributes on edges.\n    group0_nodes : list or set\n        Nodes from one bipartite group (used for layout positioning).\n    title : str, optional\n        Title of the plot.\n    figsize : tuple\n        Figure size in inches.\n    node_size : int\n        Size of the nodes in the plot.\n    font_size : int\n        Font size for node labels.\n\n    Returns\n    -------\n    matplotlib.axes.Axes\n        The matplotlib Axes object of the plot.\n    \"\"\"\n    fig, ax = plt.subplots(figsize=figsize)\n\n    # Layout\n    pos = nx.bipartite_layout(B, group0_nodes)\n\n    # Extract weights\n    edges = B.edges(data=True)\n    weights = [d['weight'] for (_, _, d) in edges]\n    max_weight = max(weights) if weights else 1  # avoid division by zero\n\n    # Draw network\n    nx.draw(\n        B, pos, ax=ax, with_labels=True, node_size=node_size, font_size=font_size,\n        edge_color=weights,\n        width=[w / max_weight * 5 for w in weights],\n        edge_cmap=plt.cm.Blues\n    )\n\n    if title:\n        ax.set_title(title)\n\n    plt.tight_layout()\n    return ax\n</code></pre>"},{"location":"reference/#faonet.plots.plot_degree_bar","title":"<code>plot_degree_bar(df, country_col='Reporter Country', degree_col='Degree', title='Node Degree', xlabel='Country', ylabel='Degree', color='blue', alpha=0.7, figsize=(12, 6), rotation=90)</code>","text":"<p>Plot a bar chart of node degrees (e.g., exporters or importers) in a bipartite network.</p>"},{"location":"reference/#faonet.plots.plot_degree_bar--parameters","title":"Parameters","text":"<p>df : pandas.DataFrame     DataFrame containing node information with degree values. country_col : str     Name of the column with country or node names. degree_col : str     Name of the column with degree values. title : str     Title of the plot. xlabel : str     Label for the x-axis. ylabel : str     Label for the y-axis. color : str     Color used for the bars. alpha : float     Transparency level for the bars (0 to 1). figsize : tuple     Size of the figure in inches (width, height). rotation : int     Rotation angle of the x-axis tick labels.</p>"},{"location":"reference/#faonet.plots.plot_degree_bar--returns","title":"Returns","text":"<p>matplotlib.axes.Axes     Axes object of the created plot.</p> Source code in <code>faonet/plots.py</code> <pre><code>def plot_degree_bar(df, country_col=\"Reporter Country\", degree_col=\"Degree\", \n                    title=\"Node Degree\", xlabel=\"Country\", ylabel=\"Degree\", \n                    color=\"blue\", alpha=0.7, figsize=(12, 6), rotation=90):\n    \"\"\"\n    Plot a bar chart of node degrees (e.g., exporters or importers) in a bipartite network.\n\n    Parameters\n    ----------\n    df : pandas.DataFrame\n        DataFrame containing node information with degree values.\n    country_col : str\n        Name of the column with country or node names.\n    degree_col : str\n        Name of the column with degree values.\n    title : str\n        Title of the plot.\n    xlabel : str\n        Label for the x-axis.\n    ylabel : str\n        Label for the y-axis.\n    color : str\n        Color used for the bars.\n    alpha : float\n        Transparency level for the bars (0 to 1).\n    figsize : tuple\n        Size of the figure in inches (width, height).\n    rotation : int\n        Rotation angle of the x-axis tick labels.\n\n    Returns\n    -------\n    matplotlib.axes.Axes\n        Axes object of the created plot.\n    \"\"\"\n    df_sorted = df.sort_values(by=degree_col, ascending=False)\n\n    fig, ax = plt.subplots(figsize=figsize)\n    ax.bar(df_sorted[country_col], df_sorted[degree_col], color=color, alpha=alpha)\n\n    ax.set_xlabel(xlabel)\n    ax.set_ylabel(ylabel)\n    ax.set_title(title)\n    ax.tick_params(axis='x', rotation=rotation)\n    plt.tight_layout()\n    plt.show()\n\n    return ax\n</code></pre>"},{"location":"reference/#faonet.plots.plot_degree_by_rank","title":"<code>plot_degree_by_rank(df_reporters, df_partners, reporter_label='Exporters', partner_label='Importers', degree_col='Degree', figsize=(10, 5), reporter_color='blue', partner_color='orange', alpha=0.7, use_log_y=True, use_log_x=False, title='Node Degree by Rank', xlabel='Rank', ylabel='Degree (Number of Connections)')</code>","text":"<p>Plot degree values of reporter and partner countries sorted by rank in descending order.</p>"},{"location":"reference/#faonet.plots.plot_degree_by_rank--parameters","title":"Parameters","text":"<p>df_reporters : pandas.DataFrame     DataFrame containing degree values for reporter (exporter) nodes. df_partners : pandas.DataFrame     DataFrame containing degree values for partner (importer) nodes. reporter_label : str     Label for reporter nodes (used in legend). partner_label : str     Label for partner nodes (used in legend). degree_col : str     Column name containing degree values. figsize : tuple     Size of the figure in inches (width, height). reporter_color : str     Color used for reporter points and fit line. partner_color : str     Color used for partner points and fit line. alpha : float     Transparency level for the scatter points. use_log_y : bool     Whether to use log scale for the y-axis. use_log_x : bool     Whether to use log scale for the x-axis. title : str     Title of the plot. xlabel : str     Label for the x-axis. ylabel : str     Label for the y-axis.</p>"},{"location":"reference/#faonet.plots.plot_degree_by_rank--returns","title":"Returns","text":"<p>matplotlib.axes.Axes     The matplotlib Axes object of the plot.</p> Source code in <code>faonet/plots.py</code> <pre><code>def plot_degree_by_rank(df_reporters, df_partners,\n                        reporter_label=\"Exporters\",\n                        partner_label=\"Importers\",\n                        degree_col=\"Degree\",\n                        figsize=(10, 5),\n                        reporter_color=\"blue\",\n                        partner_color=\"orange\",\n                        alpha=0.7,\n                        use_log_y=True,\n                        use_log_x=False,\n                        title=\"Node Degree by Rank\",\n                        xlabel=\"Rank\",\n                        ylabel=\"Degree (Number of Connections)\"):\n    \"\"\"\n    Plot degree values of reporter and partner countries sorted by rank in descending order.\n\n    Parameters\n    ----------\n    df_reporters : pandas.DataFrame\n        DataFrame containing degree values for reporter (exporter) nodes.\n    df_partners : pandas.DataFrame\n        DataFrame containing degree values for partner (importer) nodes.\n    reporter_label : str\n        Label for reporter nodes (used in legend).\n    partner_label : str\n        Label for partner nodes (used in legend).\n    degree_col : str\n        Column name containing degree values.\n    figsize : tuple\n        Size of the figure in inches (width, height).\n    reporter_color : str\n        Color used for reporter points and fit line.\n    partner_color : str\n        Color used for partner points and fit line.\n    alpha : float\n        Transparency level for the scatter points.\n    use_log_y : bool\n        Whether to use log scale for the y-axis.\n    use_log_x : bool\n        Whether to use log scale for the x-axis.\n    title : str\n        Title of the plot.\n    xlabel : str\n        Label for the x-axis.\n    ylabel : str\n        Label for the y-axis.\n\n    Returns\n    -------\n    matplotlib.axes.Axes\n        The matplotlib Axes object of the plot.\n    \"\"\"\n    df_reporters_sorted = df_reporters.sort_values(by=degree_col, ascending=False)\n    df_partners_sorted = df_partners.sort_values(by=degree_col, ascending=False)\n\n    fig, ax = plt.subplots(figsize=figsize)\n\n    ax.scatter(range(1, len(df_reporters_sorted) + 1),\n               df_reporters_sorted[degree_col],\n               color=reporter_color,\n               label=reporter_label,\n               alpha=alpha)\n\n    ax.scatter(range(1, len(df_partners_sorted) + 1),\n               df_partners_sorted[degree_col],\n               color=partner_color,\n               label=partner_label,\n               alpha=alpha)\n\n    if use_log_y:\n        ax.set_yscale(\"log\")\n    if use_log_x:\n        ax.set_xscale(\"log\")\n\n    ax.set_xlabel(xlabel)\n    ax.set_ylabel(ylabel)\n    ax.set_title(title)\n    ax.legend()\n    ax.grid(True)\n    plt.tight_layout()\n    plt.show()\n\n    return ax\n</code></pre>"},{"location":"reference/#faonet.plots.plot_degree_comparison","title":"<code>plot_degree_comparison(df_reporters, df_partners, reporter_country_col='Reporter Country', partner_country_col='Partner Country', degree_col='Degree', figsize=(12, 10), reporter_color='blue', partner_color='orange', alpha=0.7, rotation=90, use_log_scale=False)</code>","text":"<p>Plot side-by-side scatter plots comparing the degree of reporter and partner countries.</p>"},{"location":"reference/#faonet.plots.plot_degree_comparison--parameters","title":"Parameters","text":"<p>df_reporters : pandas.DataFrame     DataFrame containing degree values for reporter (exporter) nodes. df_partners : pandas.DataFrame     DataFrame containing degree values for partner (importer) nodes. reporter_country_col : str     Column name for reporter (exporter) country names. partner_country_col : str     Column name for partner (importer) country names. degree_col : str     Column name containing the degree values. figsize : tuple     Size of the entire figure in inches (width, height). reporter_color : str     Color used for the reporter scatter plot. partner_color : str     Color used for the partner scatter plot. alpha : float     Transparency level for the scatter points. rotation : int     Rotation angle for x-axis tick labels. use_log_scale : bool     If True, apply logarithmic scale to the y-axis.</p>"},{"location":"reference/#faonet.plots.plot_degree_comparison--returns","title":"Returns","text":"<p>matplotlib.figure.Figure     The matplotlib Figure object containing the two subplots.</p> Source code in <code>faonet/plots.py</code> <pre><code>def plot_degree_comparison(df_reporters, df_partners,\n                           reporter_country_col=\"Reporter Country\",\n                           partner_country_col=\"Partner Country\",\n                           degree_col=\"Degree\",\n                           figsize=(12, 10),\n                           reporter_color=\"blue\",\n                           partner_color=\"orange\",\n                           alpha=0.7,\n                           rotation=90,\n                           use_log_scale=False):\n    \"\"\"\n    Plot side-by-side scatter plots comparing the degree of reporter and partner countries.\n\n    Parameters\n    ----------\n    df_reporters : pandas.DataFrame\n        DataFrame containing degree values for reporter (exporter) nodes.\n    df_partners : pandas.DataFrame\n        DataFrame containing degree values for partner (importer) nodes.\n    reporter_country_col : str\n        Column name for reporter (exporter) country names.\n    partner_country_col : str\n        Column name for partner (importer) country names.\n    degree_col : str\n        Column name containing the degree values.\n    figsize : tuple\n        Size of the entire figure in inches (width, height).\n    reporter_color : str\n        Color used for the reporter scatter plot.\n    partner_color : str\n        Color used for the partner scatter plot.\n    alpha : float\n        Transparency level for the scatter points.\n    rotation : int\n        Rotation angle for x-axis tick labels.\n    use_log_scale : bool\n        If True, apply logarithmic scale to the y-axis.\n\n    Returns\n    -------\n    matplotlib.figure.Figure\n        The matplotlib Figure object containing the two subplots.\n    \"\"\"\n    df_reporters_sorted = df_reporters.sort_values(by=degree_col, ascending=False)\n    df_partners_sorted = df_partners.sort_values(by=degree_col, ascending=False)\n\n    fig, axs = plt.subplots(1, 2, figsize=figsize, sharey=True)\n\n    axs[0].scatter(df_reporters_sorted[reporter_country_col],\n                   df_reporters_sorted[degree_col],\n                   color=reporter_color, alpha=alpha)\n    axs[0].set_xlabel(\"Exporter Countries\")\n    axs[0].set_ylabel(\"Degree (Number of Connections)\")\n    axs[0].set_title(\"Degree - Reporter Countries\")\n    axs[0].tick_params(axis='x', rotation=rotation)\n    if use_log_scale:\n        axs[0].set_yscale('log')\n\n    axs[1].scatter(df_partners_sorted[partner_country_col],\n                   df_partners_sorted[degree_col],\n                   color=partner_color, alpha=alpha)\n    axs[1].set_xlabel(\"Importer Countries\")\n    axs[1].set_title(\"Degree - Partner Countries\")\n    axs[1].tick_params(axis='x', rotation=rotation)\n    if use_log_scale:\n        axs[1].set_yscale('log')\n\n    plt.tight_layout()\n    plt.show()\n    return\n</code></pre>"},{"location":"reference/#faonet.plots.plot_mean_clustering_ratio_vs_degree","title":"<code>plot_mean_clustering_ratio_vs_degree(df, degree_col='degree', ratio_col='C4_rate', type_col='tipo', node_col='node', show_labels=False)</code>","text":"<p>Plot the mean clustering ratio \u27e8C4b^w / C4b\u27e9 versus node degree for each node type.</p> <p>The function groups nodes by degree and computes the average clustering ratio per group, optionally displaying node labels.</p>"},{"location":"reference/#faonet.plots.plot_mean_clustering_ratio_vs_degree--parameters","title":"Parameters","text":"<p>df : pandas.DataFrame     DataFrame containing at least the clustering ratio, node degree, type and identifier columns. degree_col : str     Column name with node degrees. ratio_col : str     Column name with clustering ratio (e.g., C4b^w / C4b). type_col : str     Column name indicating node type (e.g., 'Exportador' or 'Importador'). node_col : str     Column name with node identifiers (used for optional annotations). show_labels : bool     Whether to annotate each point with its corresponding node names.</p>"},{"location":"reference/#faonet.plots.plot_mean_clustering_ratio_vs_degree--returns","title":"Returns","text":"<p>matplotlib.axes.Axes     The matplotlib Axes object of the plot.</p> Source code in <code>faonet/plots.py</code> <pre><code>def plot_mean_clustering_ratio_vs_degree(df, degree_col=\"degree\", ratio_col=\"C4_rate\", type_col=\"tipo\", node_col=\"node\", show_labels=False):\n    \"\"\"\n    Plot the mean clustering ratio \u27e8C4b^w / C4b\u27e9 versus node degree for each node type.\n\n    The function groups nodes by degree and computes the average clustering ratio per group,\n    optionally displaying node labels.\n\n    Parameters\n    ----------\n    df : pandas.DataFrame\n        DataFrame containing at least the clustering ratio, node degree, type and identifier columns.\n    degree_col : str\n        Column name with node degrees.\n    ratio_col : str\n        Column name with clustering ratio (e.g., C4b^w / C4b).\n    type_col : str\n        Column name indicating node type (e.g., 'Exportador' or 'Importador').\n    node_col : str\n        Column name with node identifiers (used for optional annotations).\n    show_labels : bool\n        Whether to annotate each point with its corresponding node names.\n\n    Returns\n    -------\n    matplotlib.axes.Axes\n        The matplotlib Axes object of the plot.\n    \"\"\"\n    # Group by type and degree\n    grouped = (\n        df.groupby([type_col, degree_col])\n        .agg({\n            ratio_col: \"mean\",\n            node_col: lambda x: ', '.join(x)\n        })\n        .reset_index()\n        .rename(columns={node_col: \"nodos\"})\n    )\n\n    # Create figure\n    fig, ax = plt.subplots(figsize=(10, 6))\n\n    # Plot each type separately\n    for tipo in grouped[type_col].unique():\n        subset = grouped[grouped[type_col] == tipo]\n        ax.plot(subset[degree_col], subset[ratio_col],\n                label=tipo,\n                marker='o' if tipo.lower().startswith(\"export\") else 's',\n                linestyle='-')\n\n        if show_labels:\n            for _, row in subset.iterrows():\n                ax.annotate(row[\"nodos\"], (row[degree_col], row[ratio_col]), fontsize=6)\n\n    # Labels and styling\n    ax.set_xlabel(\"Degree\")\n    ax.set_ylabel(\"\u27e8C4b^w / C4b\u27e9\")\n    ax.set_title(\"Mean clustering ratio \u27e8C4b^w / C4b\u27e9 vs. Degree by node type\")\n    ax.grid(True)\n    ax.legend()\n    plt.tight_layout()\n\n    return ax\n</code></pre>"},{"location":"reference/#faonet.plots.plot_top_betweenness","title":"<code>plot_top_betweenness(df, col, title=None, color='steelblue', top_n=10, label_col='node', xlabel='Betweenness Centrality')</code>","text":"<p>Plot a horizontal bar chart of the top N nodes ranked by betweenness centrality.</p>"},{"location":"reference/#faonet.plots.plot_top_betweenness--parameters","title":"Parameters","text":"<p>df : pandas.DataFrame     DataFrame containing betweenness values and node labels. col : str     Column name containing betweenness centrality scores. title : str, optional     Title of the plot (default is None). color : str     Color of the bars in the chart. top_n : int     Number of top-ranking nodes to display. label_col : str     Column name with node identifiers (default is 'node'). xlabel : str     Label for the x-axis.</p>"},{"location":"reference/#faonet.plots.plot_top_betweenness--returns","title":"Returns","text":"<p>matplotlib.axes.Axes     The matplotlib Axes object of the plot.</p> Source code in <code>faonet/plots.py</code> <pre><code>def plot_top_betweenness(df, col, title=None, color=\"steelblue\", top_n=10, label_col=\"node\", xlabel=\"Betweenness Centrality\"):\n    \"\"\"\n    Plot a horizontal bar chart of the top N nodes ranked by betweenness centrality.\n\n    Parameters\n    ----------\n    df : pandas.DataFrame\n        DataFrame containing betweenness values and node labels.\n    col : str\n        Column name containing betweenness centrality scores.\n    title : str, optional\n        Title of the plot (default is None).\n    color : str\n        Color of the bars in the chart.\n    top_n : int\n        Number of top-ranking nodes to display.\n    label_col : str\n        Column name with node identifiers (default is 'node').\n    xlabel : str\n        Label for the x-axis.\n\n    Returns\n    -------\n    matplotlib.axes.Axes\n        The matplotlib Axes object of the plot.\n    \"\"\"\n    top = df.sort_values(by=col, ascending=False).head(top_n)\n\n    fig, ax = plt.subplots(figsize=(10, 6))\n    ax.barh(top[label_col], top[col], color=color)\n    ax.set_xlabel(xlabel)\n    ax.set_title(title or f\"Top {top_n} Nodes by {col}\")\n    ax.invert_yaxis()\n    plt.tight_layout()\n    plt.show()\n\n    return ax\n</code></pre>"},{"location":"reference/#faonet.plots.plot_trade_scatter","title":"<code>plot_trade_scatter(df, x_col='Reporter Country Code (M49)', y_col='Partner Country Code (M49)', value_col='Value', step=10, cmap='viridis', alpha=0.8, figsize=(8, 6))</code>","text":"<p>Plot a scatter plot of trade interactions between reporter and partner countries.</p>"},{"location":"reference/#faonet.plots.plot_trade_scatter--parameters","title":"Parameters","text":"<p>df : pd.DataFrame     DataFrame containing trade data. x_col : str     Column name for x-axis (e.g. reporter country codes). y_col : str     Column name for y-axis (e.g. partner country codes). value_col : str     Column name used for point color intensity (e.g. trade value). step : int     Interval of tick marks on the axes (e.g. show every 10th value). cmap : str     Colormap to use for the scatter points. alpha : float     Transparency level for the points. figsize : tuple     Figure size in inches.</p>"},{"location":"reference/#faonet.plots.plot_trade_scatter--returns","title":"Returns","text":"<p>matplotlib.axes.Axes     The plot axes object.</p> Source code in <code>faonet/plots.py</code> <pre><code>def plot_trade_scatter(df, x_col='Reporter Country Code (M49)', y_col='Partner Country Code (M49)', \n                       value_col='Value', step=10, cmap='viridis', alpha=0.8, figsize=(8, 6)):\n    \"\"\"\n    Plot a scatter plot of trade interactions between reporter and partner countries.\n\n    Parameters\n    ----------\n    df : pd.DataFrame\n        DataFrame containing trade data.\n    x_col : str\n        Column name for x-axis (e.g. reporter country codes).\n    y_col : str\n        Column name for y-axis (e.g. partner country codes).\n    value_col : str\n        Column name used for point color intensity (e.g. trade value).\n    step : int\n        Interval of tick marks on the axes (e.g. show every 10th value).\n    cmap : str\n        Colormap to use for the scatter points.\n    alpha : float\n        Transparency level for the points.\n    figsize : tuple\n        Figure size in inches.\n\n    Returns\n    -------\n    matplotlib.axes.Axes\n        The plot axes object.\n    \"\"\"\n    ax = df.plot(kind='scatter', x=x_col, y=y_col, s=32, c=value_col, \n                 cmap=cmap, alpha=alpha, figsize=figsize)\n\n    # Define ticks\n    x_ticks = df[x_col].unique()\n    y_ticks = df[y_col].unique()\n    ax.set_xticks(x_ticks[::step])\n    ax.set_yticks(y_ticks[::step])\n\n    # Style\n    ax.spines[['top', 'right']].set_visible(False)\n    plt.tight_layout()\n    plt.show()\n\n    return ax\n</code></pre>"},{"location":"reference/#faonet.plots.plot_weight_matrix","title":"<code>plot_weight_matrix(df, row='Partner Countries', col='Reporter Countries', value='Value', cmap='coolwarm', figsize=(20, 15), title='Weighted Adjacency Matrix (Trade Volume)')</code>","text":"<p>Plot a heatmap of the weighted bipartite adjacency matrix.</p>"},{"location":"reference/#faonet.plots.plot_weight_matrix--parameters","title":"Parameters","text":"<p>df : pandas.DataFrame     DataFrame containing filtered trade data with exporter, importer, and weight columns. row : str     Column name to use as rows of the matrix (typically importers). col : str     Column name to use as columns of the matrix (typically exporters). value : str     Column containing the weight or value of the trade relationship. cmap : str     Colormap used for the heatmap. figsize : tuple     Size of the figure in inches (width, height). title : str     Title of the plot.</p>"},{"location":"reference/#faonet.plots.plot_weight_matrix--returns","title":"Returns","text":"<p>matplotlib.axes.Axes     The Axes object of the resulting heatmap.</p> Source code in <code>faonet/plots.py</code> <pre><code>def plot_weight_matrix(df, row=\"Partner Countries\", col=\"Reporter Countries\", \n                       value=\"Value\", cmap=\"coolwarm\", figsize=(20, 15), \n                       title=\"Weighted Adjacency Matrix (Trade Volume)\"):\n    \"\"\"\n    Plot a heatmap of the weighted bipartite adjacency matrix.\n\n    Parameters\n    ----------\n    df : pandas.DataFrame\n        DataFrame containing filtered trade data with exporter, importer, and weight columns.\n    row : str\n        Column name to use as rows of the matrix (typically importers).\n    col : str\n        Column name to use as columns of the matrix (typically exporters).\n    value : str\n        Column containing the weight or value of the trade relationship.\n    cmap : str\n        Colormap used for the heatmap.\n    figsize : tuple\n        Size of the figure in inches (width, height).\n    title : str\n        Title of the plot.\n\n    Returns\n    -------\n    matplotlib.axes.Axes\n        The Axes object of the resulting heatmap.\n    \"\"\"\n    # Build matrix\n    matrix = df.pivot(index=row, columns=col, values=value)\n\n    # Sort rows/cols by total weights\n    matrix = matrix.loc[matrix.sum(axis=1).sort_values(ascending=False).index,\n                        matrix.sum(axis=0).sort_values(ascending=False).index]\n\n    # Plot\n    plt.figure(figsize=figsize)\n    ax = sns.heatmap(matrix, cmap=cmap, annot=False, linewidths=0.5)\n\n    plt.xlabel(col)\n    plt.ylabel(row)\n    plt.title(title)\n    plt.tight_layout()\n    plt.show()\n\n    return ax\n</code></pre>"},{"location":"reference/#export-tools","title":"Export Tools","text":""},{"location":"reference/#faonet.export.export_gml","title":"<code>export_gml(G, filepath)</code>","text":"<p>Export a NetworkX graph to a GML file.</p>"},{"location":"reference/#faonet.export.export_gml--parameters","title":"Parameters","text":"<p>G : networkx.Graph     The graph to be exported. filepath : str     Path to the output .gml file.</p> Source code in <code>faonet/export.py</code> <pre><code>def export_gml(G, filepath):\n    \"\"\"\n    Export a NetworkX graph to a GML file.\n\n    Parameters\n    ----------\n    G : networkx.Graph\n        The graph to be exported.\n    filepath : str\n        Path to the output .gml file.\n    \"\"\"\n    nx.write_gml(G, filepath)\n</code></pre>"},{"location":"reference/#fitting","title":"Fitting","text":""},{"location":"reference/#faonet.fitting.fit_strength_vs_degree","title":"<code>fit_strength_vs_degree(df_exporters, df_importers, degree_col='Degree', strength_col='Strength', figsize=(8, 5), show_plot=True)</code>","text":"<p>Fit and plot strength vs. degree in log-log scale for exporters and importers.</p>"},{"location":"reference/#faonet.fitting.fit_strength_vs_degree--parameters","title":"Parameters","text":"<pre><code>df_exporters (pd.DataFrame): Exporters' degree and strength.\ndf_importers (pd.DataFrame): Importers' degree and strength.\ndegree_col (str): Column name for degree values.\nstrength_col (str): Column name for strength values.\nfigsize (tuple): Size of the plot.\nshow_plot (bool): Whether to display the plot.\n</code></pre> <p>Returns:</p> Name Type Description <code>dict</code> <p>Dictionary containing slopes, intercepts, R\u00b2 values, and fitted data.</p> Source code in <code>faonet/fitting.py</code> <pre><code>def fit_strength_vs_degree(df_exporters, df_importers,\n                           degree_col=\"Degree\", strength_col=\"Strength\",\n                           figsize=(8, 5), show_plot=True):\n    \"\"\"\n    Fit and plot strength vs. degree in log-log scale for exporters and importers.\n\n    Parameters\n    ----------\n        df_exporters (pd.DataFrame): Exporters' degree and strength.\n        df_importers (pd.DataFrame): Importers' degree and strength.\n        degree_col (str): Column name for degree values.\n        strength_col (str): Column name for strength values.\n        figsize (tuple): Size of the plot.\n        show_plot (bool): Whether to display the plot.\n\n    Returns:\n        dict: Dictionary containing slopes, intercepts, R\u00b2 values, and fitted data.\n    \"\"\"\n    def power_law_fit(degree_vals, strength_vals):\n        mask = (degree_vals &gt; 0) &amp; (strength_vals &gt; 0)\n        degree_vals = degree_vals[mask]\n        strength_vals = strength_vals[mask]\n\n        log_degree = np.log10(degree_vals)\n        log_strength = np.log10(strength_vals)\n\n        slope, intercept, r_value, _, _ = linregress(log_degree, log_strength)\n\n        sorted_indices = np.argsort(degree_vals)\n        degree_sorted = degree_vals[sorted_indices]\n        fit_strength = 10 ** intercept * degree_sorted ** slope\n\n        return slope, intercept, r_value**2, degree_sorted, fit_strength\n\n    # Ajustes\n    slope_exp, intercept_exp, r2_exp, deg_exp, fit_exp = power_law_fit(\n        df_exporters[degree_col].values,\n        df_exporters[strength_col].values)\n\n    slope_imp, intercept_imp, r2_imp, deg_imp, fit_imp = power_law_fit(\n        df_importers[degree_col].values,\n        df_importers[strength_col].values)\n\n    if show_plot:\n        plt.figure(figsize=figsize)\n        plt.xscale('log')\n        plt.yscale('log')\n        plt.xlabel('Degree (Number of Connections)')\n        plt.ylabel('Strength (Sum of Weights)')\n        plt.title('Power-law Fit: Strength vs Degree')\n        plt.grid(True)\n\n        # Puntos\n        plt.scatter(df_exporters[degree_col], df_exporters[strength_col], \n                    alpha=0.7, color='blue', label=f'Exporters (\u03b1={slope_exp:.2f})')\n        plt.scatter(df_importers[degree_col], df_importers[strength_col],\n                    alpha=0.7, color='orange', label=f'Importers (\u03b1={slope_imp:.2f})')\n\n        # L\u00edneas de ajuste\n        plt.plot(deg_exp, fit_exp, color='blue', linestyle='dashed')\n        plt.plot(deg_imp, fit_imp, color='orange', linestyle='dashed')\n\n        plt.legend()\n        plt.tight_layout()\n        plt.show()\n\n    return {\n        \"exporters\": {\n            \"slope\": slope_exp,\n            \"intercept\": intercept_exp,\n            \"r_squared\": r2_exp,\n            \"x\": deg_exp,\n            \"fit\": fit_exp\n        },\n        \"importers\": {\n            \"slope\": slope_imp,\n            \"intercept\": intercept_imp,\n            \"r_squared\": r2_imp,\n            \"x\": deg_imp,\n            \"fit\": fit_imp\n        }\n    }\n</code></pre>"},{"location":"reference/#faonet.fitting.fit_truncated_power_law","title":"<code>fit_truncated_power_law(degrees, title='Truncated Power-Law Fit', xlabel='Degree', ylabel='Frequency', show_plot=True, figsize=(8, 6), color_data='black', color_fit='darkred')</code>","text":"<p>Fit a truncated power-law to a degree distribution and optionally plot the result.</p>"},{"location":"reference/#faonet.fitting.fit_truncated_power_law--parameters","title":"Parameters","text":"<pre><code>degrees (array-like): Degree values (not yet counted).\ntitle (str): Title of the plot.\nxlabel (str): Label for x-axis.\nylabel (str): Label for y-axis.\nshow_plot (bool): Whether to display the plot.\nfigsize (tuple): Size of the figure.\ncolor_data (str): Color for scatter data.\ncolor_fit (str): Color for the fitted curve.\n</code></pre> <p>Returns:</p> Name Type Description <code>dict</code> <p>Dictionary with fit parameters and R\u00b2.</p> Source code in <code>faonet/fitting.py</code> <pre><code>def fit_truncated_power_law(degrees,\n                             title=\"Truncated Power-Law Fit\",\n                             xlabel=\"Degree\",\n                             ylabel=\"Frequency\",\n                             show_plot=True,\n                             figsize=(8, 6),\n                             color_data=\"black\",\n                             color_fit=\"darkred\"):\n    \"\"\"\n    Fit a truncated power-law to a degree distribution and optionally plot the result.\n\n    Parameters\n    ----------\n        degrees (array-like): Degree values (not yet counted).\n        title (str): Title of the plot.\n        xlabel (str): Label for x-axis.\n        ylabel (str): Label for y-axis.\n        show_plot (bool): Whether to display the plot.\n        figsize (tuple): Size of the figure.\n        color_data (str): Color for scatter data.\n        color_fit (str): Color for the fitted curve.\n\n    Returns:\n        dict: Dictionary with fit parameters and R\u00b2.\n    \"\"\"\n    degrees = np.asarray(degrees)\n    values, counts = np.unique(degrees, return_counts=True)\n\n    # Fit\n    popt, _ = curve_fit(truncated_power_law, values, counts, maxfev=10000)\n    fit_values = truncated_power_law(values, *popt)\n    r2 = r_squared(counts, fit_values)\n\n    if show_plot:\n        plt.figure(figsize=figsize)\n        plt.scatter(values, counts, label=\"Data\", color=color_data)\n        plt.plot(values, fit_values, label=f\"Fit (R\u00b2 = {r2:.2f})\", color=color_fit)\n        plt.xlabel(xlabel)\n        plt.ylabel(ylabel)\n        plt.title(title)\n        plt.legend()\n        plt.grid(True)\n        plt.tight_layout()\n        plt.show()\n\n    return {\n        \"parameters\": {\"a\": popt[0], \"b\": popt[1], \"c\": popt[2]},\n        \"r_squared\": r2,\n        \"x\": values,\n        \"y\": counts,\n        \"fit\": fit_values\n    }\n</code></pre>"},{"location":"reference/#faonet.fitting.r_squared","title":"<code>r_squared(y_true, y_pred)</code>","text":"<p>Compute the coefficient of determination (R\u00b2) between observed and predicted values.</p>"},{"location":"reference/#faonet.fitting.r_squared--parameters","title":"Parameters","text":"<p>y_true : array-like     Observed data values. y_pred : array-like     Fitted or predicted data values.</p>"},{"location":"reference/#faonet.fitting.r_squared--returns","title":"Returns","text":"<p>float     R\u00b2 value indicating the goodness of fit.</p> Source code in <code>faonet/fitting.py</code> <pre><code>def r_squared(y_true, y_pred):\n    \"\"\"\n    Compute the coefficient of determination (R\u00b2) between observed and predicted values.\n\n    Parameters\n    ----------\n    y_true : array-like\n        Observed data values.\n    y_pred : array-like\n        Fitted or predicted data values.\n\n    Returns\n    -------\n    float\n        R\u00b2 value indicating the goodness of fit.\n    \"\"\"\n    ss_res = np.sum((y_true - y_pred) ** 2)\n    ss_tot = np.sum((y_true - np.mean(y_true)) ** 2)\n    return 1 - (ss_res / ss_tot)\n</code></pre>"},{"location":"reference/#faonet.fitting.truncated_power_law","title":"<code>truncated_power_law(x, a, b, c)</code>","text":"<p>Truncated power-law function.</p>"},{"location":"reference/#faonet.fitting.truncated_power_law--parameters","title":"Parameters","text":"<p>x : array-like     Degree values. a : float     Scaling factor. b : float     Power-law exponent. c : float     Cutoff parameter.</p>"},{"location":"reference/#faonet.fitting.truncated_power_law--returns","title":"Returns","text":"<p>array-like     Values computed from the truncated power-law formula: a * x^(-b) * exp(-x/c).</p> Source code in <code>faonet/fitting.py</code> <pre><code>def truncated_power_law(x, a, b, c):\n    \"\"\"\n\n    Truncated power-law function.\n\n    Parameters\n    ----------\n    x : array-like\n        Degree values.\n    a : float\n        Scaling factor.\n    b : float\n        Power-law exponent.\n    c : float\n        Cutoff parameter.\n\n    Returns\n    -------\n    array-like\n        Values computed from the truncated power-law formula: a * x^(-b) * exp(-x/c).\n    \"\"\"\n    return a * np.power(x, -b) * np.exp(-x / c)\n</code></pre>"}]}